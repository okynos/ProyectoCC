{
  "name": "Nochat",
  "tagline": "Proyecto desarrollado en la asignatura de Cloud Computing desplegado en la web",
  "body": "# NoChat ![NoChat](https://github.com/okynos/ProyectoCC/blob/master/resources/images/logo.png?raw=true)\r\n\r\n[![License](https://img.shields.io/aur/license/yaourt.svg?style=plastic)](https://github.com/okynos/ProyectoCC/blob/master/LICENSE)\r\n[![Status](https://img.shields.io/badge/Status-documenting-yellow.svg)](https://github.com/okynos/ProyectoCC/blob/master/README.md)\r\n[![Language](https://img.shields.io/badge/language-NodeJS-green.svg)](https://nodejs.org/es/)\r\n[![Language](https://img.shields.io/badge/language-Python-green.svg)](https://www.python.org/)\r\n[![Language](https://img.shields.io/badge/language-Go-green.svg)](https://golang.org/)\r\n#### José Luis Fernández Aguilera - Cloud Computing\r\n\r\n#### ¡Novedades! \r\n* Orquestación\r\n\r\n## Indice\r\n* Resumen\r\n* Arquitectura\r\n* Desarrollo\r\n* Provisionamiento\r\n* Orquestación\r\n\r\n## Documentación.\r\nLa documentación del proyecto se divide en varios subapartados en los cuales se detallan los distintos aspectos de la aplicación que se va a desarrollar.\r\n\r\n### Breve resumen\r\nEste proyecto se basa en una aplicación web que permite a los usuarios chatear entre sí mediante sockets de la libreria socket.io con conexión y desconexión en tiempo real a la web y todo ello con nodejs.\r\nEste proyecto variará en función de lo aprendido en la asignatura de Cloud Computing incluso llegando a la posibilidad de cambiar totalmente el tipo de proyecto a desarrollar para centrarse más en la arquitectura de micro servicios más idónea para despliegue en la nube facilitando así la escalabilidad del sistema.\r\nDividiendo el proyecto entre una aplicación que realiza las tareas de administración y gestión de usuarios y los servicios de los que dispone que no tienen porque encontrarse en la misma máquina y ni siquiera utilizar el mismo lenguaje o ser programadas por mi mismo puede ser de terceros gracias a la utilización del protocolo REST.\r\n\r\n### Arquitectura\r\nLa arquitectura de la aplicación se basa en una arquitectura de microservicios, en la cual existe un controlador central el cual utilizará un sistema de colas llamado RabbitMQ, que gestionará la llegada de eventos a la aplicación y llamará a los microservicios necesarios para realizar el evento.\r\n\r\nEn nuestra arquitectura contaremos con 6 microservicios propios:\r\n- Microservicio de logeo propio con MongoDB para loguear todos los sucesos de la aplicación.\r\n- Microservicio de gestión de sockets e interconexión entre usuarios.\r\n- Microservicio de notificaciones.\r\n- Microservicio de gestión del almacenamiento de usuarios utilizando una base de datos relacional.\r\n- Microservicio de presentación y gestión (interfaz).\r\n\r\nTambién se utilizarán unos microservicios externos:\r\n- Microservicio de logging de datos del servidor externo a nuestros microservicios.\r\n- Microservicio de gestión del almacenamiento redundante de datos externo.\r\n\r\nDados todos los microservicios enumerados se puede presuponer que la estructura se basará en una aplicación que hará de gestor/controlador e irá llamando a cada uno de los microservicios que se necesiten en un momento dado. \r\n\r\n### Desarrollo\r\nEsta aplicación que actuará de controlador se programará en NodeJS (Javascript) y utilizará el servicio de RabbitMQ para gestionar las colas de eventos que se produzcan.\r\n\r\nEn cuanto a los lenguajes que se utilizarán en los microservicios no está bien definido y se escogerán varios en función de las capacidades o el que mejor se adapte a la tarea que se ha descrito en el inicio del readme, algunos posibles lenguajes son:\r\n- JavaScript o NodeJS\r\n- Python\r\n- Go (para aprender)\r\n- Java\r\n- Otros.\r\n\r\nCada microservicio puede tener un lenguaje independientemente de los demás es por ello que no se especifica ningún lenguaje concreto.\r\n\r\nPara comenzar este proyecto se parte de una base ya realizada de un chat en NodeJS pero de estructura monolítica que se adaptará a la arquitectura de microservicios separando y modularizando el código necesario.\r\n\r\n### Provisionamiento\r\nPara desplegar esta aplicación son necesarios una serie de aplicaciones de tipo servidor, que la mayoría de distribuciones no incorporan en su imagen base, es por ello que vamos a realizar un provisionamiento de los paquetes básicos, que necesitarán luego nuestras aplicaciones en las máquinas desplegadas en la red, para ello podemos utilizar varios lenguajes de provisionamiento de máquinas como pueden ser Chef, Salt, Rex, Puppet, Ansible y alguno más que no he nombrado pero en nuestro caso vamos a realizarlo en dos sistemas diferentes, Ansible y Rex.\r\n\r\n##### Provisionando con Ansible\r\nAnsible es una aplicación de provisionamiento que permite la instalación de paquetes a través de una consola python la cual puede ejecutar cualquier tipo de instrucción que se define en un lenguaje de descripción llamado en este caso YAML.\r\n\r\nPara empezar a provisionar en Ansible es necesario asegurarse que la máquina que queremos provisionar cuenta con una instalación de python2.7 dado que es la versión que utiliza, si queremos instalar módulos de python será necesario tambien el paquete python-pip.\r\n\r\ninicialmente es necesario intalar en la máquina que provisiona/anfitrión unos módulo python que utilizará ansible y el propio ansible con el comando:\r\n\r\n```\r\nsudo pip install paramiko PyYAML jinja2 httplib2 ansible\r\n```\r\n\r\nUna vez se hayan instalado todas las dependencias es mejor para nuestro diseño crearnos un archivo de hosts el cual Ansible utilizará para provisionar las máquinas que definamos en él y lo exportamos como variable de entorno.\r\n\r\n```\r\necho \"[NOMBRE GRUPO MÁQUINAS]\" > ~/ansible_hosts\r\necho \"IP O DIRECCIÓN DE LA MÁQUINA\" >> ~/ansible_hosts\r\nexport ANSIBLE_HOSTS=~/ansible_hosts\r\n```\r\n\r\nCon esto ya tendríamos toda la configuración de la parte de ansible realizada, sólo necesitamos lanzar el script con la siguiente orden y observar la salida que nos va dando, los scripts de provisionamiento se pueden encontrar [aquí](https://github.com/okynos/ProyectoCC/tree/master/provisionamiento):\r\n\r\n```\r\nansible-playbook scriptAnsible.yml --private-key keypair.pem\r\n```\r\n\r\nDonde keypair es vuestra clave de acceso a la máquina por ssh, si tenéis copiada una clave pública en la máquina remota no sería necesario este parámetro, es porsible que tengais que cambiar el nombre de usuario en el script o ponerlo por línea de órdenes con la opción -u para conectaros con el usuario de vuestra máquina remota.\r\n\r\n\r\n##### Provisionando con Rex\r\nEn este caso para instalar Rex sólo es necesario instalar el paquete llamado rex desde línea de comandos en Ubuntu, en otros casos será necesario ejecutar la siguiente orden:\r\n\r\n```\r\ncurl -L https://get.rexify.org | perl - --sudo -n Rex\r\n```\r\n\r\nEsto descargará e instalará Rex en nuestro equipo, una vez hecho esto ya podemos empezar a escribir un script de provisionamiento.\r\n\r\nRex utiliza un lenguaje descriptivo al igual que otras aplicaciones el script de provisionamiento que se ha creado está [aquí](https://github.com/okynos/ProyectoCC/tree/master/provisionamiento):\r\n\r\n\r\nEste script se debe llamar Rexfile y está dividido en dos tareas dependiendo del tipo de servicio que queramos provisionar en nuestro caso son \"deployServers\" para instalar todos los servidores (RabbitMQ, Mysql, Mongo) y \"deployNode\" para instalar NodeJs y todas las dependencias requeridas.\r\n\r\nPara ejecutar este script sólo es necesario lanzar la siguiente orden en el directorio donde se encuentre el fichero Rexfile:\r\n\r\n```\r\nrex deployServers\r\nrex deplouNode\r\n```\r\n\r\nDependiendo del servicio que queramos provisionar lanzaremos un comando u otro para instalar los paquetes que se hayan codificado en el Rexfile.\r\n\r\n\r\n### Orquestación\r\nPara orquestación de máquinas virtuales se ha utilizado la herramienta de orquestación configuración y en algunos momentos provisionamiento llamada vagrant la cual permite lanzar instancias de una misma imagen o box como se denominan a las imágenes ya preparadas para ser utilizadas con vagrant, en este caso hemos realizado orquestación de tres formas diferentes que pasamos a detallar pero antes es necesario explicar los pasos que se requieren para instalar vagrant en nuestra máquina anfitrión.\r\n\r\nPara instalar vagrant se pued erecurrir al repositorio oficial de vuestra distribución que es posible que contenga una versión un tanto antigua(1.8.1) en mi caso a si que podemos descargar la última versión desde la [página de vagrant](https://www.vagrantup.com/downloads.html) de nuevo en mi caso la instalación de la última versión no me ha funcionado correctamente por lo tanto yo recomiendo la 1.8.7, podemos seguir estos comandos para descargarla e instalarla:\r\n\r\n```\r\nwget https://releases.hashicorp.com/vagrant/1.8.7/vagrant_1.8.7_x86_64.deb\r\nsudo dpkg -i vagrant_1.8.7_x86_64.deb\r\nsudo apt-get install ruby\r\n```\r\n\r\nuna vez tenemos vagrant disponible pasamos a la parte de orquestación.\r\n\r\n\r\n##### Orquestación vagrant y virtualbox\r\nEn este caso vamos a orquestar máquinas virtuales en nuestra propia máquina, para ello necesitamos instalar algún proveedor de virtualización como es el caso de virtualbox, al igual que con vagrant es necesario instalarlo por lo que nos dirigimos a la [página de virtualbox](https://www.virtualbox.org/) o nos lo descargamos e instalamos con los siguientes comandos(Ubuntu 16.04 x64):\r\n\r\n```\r\nwget http://download.virtualbox.org/virtualbox/5.1.10/virtualbox-5.1_5.1.10-112026~Ubuntu~xenial_amd64.deb\r\nsudo dpkg -i virtualbox-5.1_5.1.10-112026~Ubuntu~xenial_amd64.deb\r\n```\r\n\r\nEn algunos tipos de virtualizaciones nos puede ser útil el pack de extensiones de virtualbox lo podemos instalar así:\r\n\r\n```\r\nwget http://download.virtualbox.org/virtualbox/5.1.10/Oracle_VM_VirtualBox_Extension_Pack-5.1.10-112026.vbox-extpack\r\nsudo VBoxManage extpack install Oracle_VM_VirtualBox_Extension_Pack-5.1.10-112026.vbox-extpack\r\n```\r\n\r\nAhora necesitamos una imagen de un sistema operativo para lanzarlo a través de virtualbox, para ello ejecutamos el comando:\r\n\r\n```\r\nvagrant box add https://atlas.hashicorp.com/ARTACK/boxes/debian-jessie\r\n```\r\nNos descargará una imagen de Debian Jessie llamada en este caso ARTACK/debian-jessie ahora la inicializamos y lanzamos con:\r\n\r\n```\r\nvagrant init ARTACK/debian-jessie\r\nvagrant up\r\nvagrant ssh\r\n```\r\nDe esta forma utilizando varios directorios podemos lanzar las máquinas que necesitemos orquestar y conectarnos a ellas.\r\n\r\n\r\n##### Orquestación vagrant y libvirt\r\nEn este caso vamos a orquestar máquinas virtuales de la misma manera que con virtualbox, en una máquina local pero en vez de utilizar virtualbox, vamos a utilizar una libreria llamada libvirt la cual se encarga de adaptar las instrucciones de vagrant a cualquiera de los sistemas de virtualización basados en linux como qemu(KVM) o lxc para realizar orquestación con libvirt solo es necesario seguir los siguientes pasos:\r\n\r\n```\r\nsudo apt-get install qemu libvirt-bin libvirt0 ebtables dnsmasq\r\nsudo apt-get install libxslt1-dev libxml2-dev libvirt-dev zlib1g-dev ruby-dev\r\nsudo vagrant plugin install vagrant-libvirt\r\ngem pristine ruby-libvirt\r\n```\r\nEste proceso nos va a instalar todas las dependencias de libvirt y a instalar el plugin en vagrant ya solo necesitamos configurar la imagen`para probar libvirt vamos a descargar una imagen preparada para virtualizarse con KVM.\r\n\r\n```\r\nvagrant box add https://atlas.hashicorp.com/viniciusfs/boxes/centos6/\r\n```\r\nEsto nos descargará una distro llamada viniciusfs/centos6`la inicializamos y lanzamos.\r\n\r\n```\r\nvagrant init viniciusfs/centos6\r\nvagrant up --provider=libvirt\r\nvagrant ssh\r\n```\r\nEs necesario especificar el proveedor.\r\n\r\n##### Orquestación vagrant y OpenStack\r\nFinalmente solo nos queda la orquestación más compleja orquestación en un servidor remoto, en nuestro caso vamos a utilizar la plataforma gratuita trystack la cual nos permite orquestar hasta 3 máquinas virtuales aunque con algunas limitaciones.\r\n\r\nEn un primer paso ya deberíamos tener configurado tanto vagrant como todas las dependencias que fueran necesarias por lo tanto nos saltamos algunos pasos y ejecutamos:\r\n\r\n```\r\nsudo vagrant plugin install vagrant-openstack-provider\r\n```\r\nEsto nos instalará el plugin de openstack para vagrant, una vez instalado nos dirigimos a un directorio vacío y creamos un Vagrantfile con el siguiente contenido para conectar con trystack:\r\n\r\n```\r\nVagrant.configure(2) do |config|\r\n\r\n  # Specify the default SSH username and private key\r\n  config.ssh.username = \"NOMBRE_DE_USUARIO_EN_LA_IMAGEN\"\r\n  config.ssh.private_key_path = \"PATH_AL_FICHERO_PEM\"\r\n\r\n  # Configure the OpenStack provider for Vagrant\r\n  config.vm.provider \"openstack\" do |os|\r\n\r\n    # Specify OpenStack authentication information\r\n    os.openstack_auth_url = \"http://DIRECCIÓN_SERVIDOR_OPENSTACK:5000/v2.0\"\r\n    os.username = \"USUARIO_OPENSTACK\"\r\n    os.password = \"CLAVE_OPENSTACK\"\r\n    os.tenant_name = \"NOMBRE_DEL_PROYECTO\"\r\n\r\n    # Specify instance information\r\n    os.server_name = \"NOMBRE_DE_LA_MÁQUINA_A_CREAR\"\r\n    os.flavor = \"m1.smaller\"\r\n    os.image = \"NOMBRE_DE_LA_IMAGEN_EN_OPENSTACK\"\r\n    os.floating_ip_pool = \"public\"\r\n    os.networks = \"RED_OPENSTACK\"\r\n    os.keypair_name = \"NOMBRE_DEL_FICHERO_PEM\"\r\n    os.security_groups = [\"default\"]\r\n  end\r\nend\r\n```\r\n\r\nSerá necesario que modifiques el fichero con la configuración propia que Openstack o Trystack proporciona.\r\nPara finalizar solo será necesario lanzar vagrant y se creará la máquina en el servidor remoto.\r\n\r\n```\r\nsudo vagrant up\r\nansible-playbook scriptAnsible.yml --private-key PATH_A_FICHERO_PEM\r\n```\r\n\r\nY si queremos destruir la instancia solo tenemos que hacer:\r\n```\r\nsudo vagrant destroy\r\n```\r\n\r\n\r\n##### Provisionamiento y orquestación\r\nUn último paso necesario tras la orquestación es el provisionamiento, el cual en este caso se realiza a través del propio vagrant con ejecuciones shell pero eso no es práctico ya que las imágenes pueden variar su intérprete por lo tanto es mucho más cómodo provisionar como hasta ahora lo hemos hecho en nuestro caso con Rex o Ansible los cuales son capaces de provisionar las máquinas orquestadas con vagrant de una manera sencilla tras crear una instancia con vagrant solo es necesario llamar a Rex o a Ansible con una orden indicandole la dirección que tiene que provisionar de esta manera podemos orquestar y provisionar multitud de máquinas de manera muy rápida.\r\n\r\nUn ejemplo para provisionar una máquina instanciada con vagrant y provisionada con Ansible es el siguiente:\r\n\r\n```\r\nsudo vagrant up\r\nansible-playbook scriptAnsible.yml --private-key ~/keys/keypair.pem\r\n```\r\n\r\nEn caso que deseemos provisionar la máquina de openstack al mismo tiempo que la creamos es necesario añadir este código al vagrantfile\r\n```\r\n  config.vm.provision \"ansible\" do |ansible|\r\n    ansible.playbook = \"scriptAnsible.yml\"\r\n    ansible.limit = \"all\"\r\n    ansible.raw_arguments = [\"-i\" + floating_ip + \",\"]\r\n  end\r\n```\r\nDentro de la zona de config de vagrant.\r\n\r\nY modificar ligeramente el script cambiando la línea hosts para que provisiones todas las máquinas que se le pasen como parámetro.\r\n```\r\n---\r\n- hosts: all\r\n  become: yes\r\n  remote_user: ubuntu\r\n  tasks:\r\n  - name: Update repo\r\n    apt: \r\n      update_cache: yes\r\n  - name: Install MongoDB Server\r\n    apt: pkg=mongodb-server state=installed\r\n  - name: Install Mysql Server\r\n    apt: pkg=mysql-server state=installed\r\n  - name: Install RabbitMQ Server\r\n    apt: pkg=rabbitmq-server state=installed\r\n```\r\n\r\nFinalmente para provisionar la máquina ejecutamos el comando:\r\n```\r\nsudo vagrant provision\r\n```\r\n\r\nEn el caso de querer lanzar y provisionar varias máquinas al mismo tiempo en OpenStack es posible pero no en la cuenta limitada de Trystack, en la sección de orquestación de este proyecto puedes encontrarlo, aún así te lo enlazo [aquí](https://github.com/okynos/ProyectoCC/blob/master/orquestacion/Vagrantfile)\r\n\r\nPara ello es necesario definir varias máquinas en el vagrantfile y provisionarlas con ansible, el problema de trystack es que solo proporciona una IP por lo que solo podremos provisionar una sola máquina al mismo tiempo sin cambiar esa IP.\r\n\r\nDemostración\r\n[Captura OpenStack](https://raw.githubusercontent.com/okynos/ProyectoCC/gh-pages/images/Captura_openstack.png)\r\n[Captura Provisionamiento](https://raw.githubusercontent.com/okynos/ProyectoCC/gh-pages/images/capturaManuel.png)\r\n\r\n### Correcciones\r\n\r\n* Añadido la documentación a través de una rama gh-pages. -> hito 0\r\n* Corregidos los issues asociados al hito 0 para que los issues se cierren con commit. -> hito 0\r\n* Añadida más documentación en este mismo fichero. -> hito 0\r\n* Añadida arquitectura y breve explicación del desarrollo. -> hito 1\r\n* Añadido procedimiento de provisionamiento. -> hito 2\r\n* Añadida aclaración de los microservicios. -> hito 2\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}